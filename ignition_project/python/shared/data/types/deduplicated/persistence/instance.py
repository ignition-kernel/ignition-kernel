





from shared.data.types.deduplicated.persistence.core import MetaBasePersistenceMixin, resolve_import_path
from shared.data.types.deduplicated.persistence.memo import EnumeratedLookup, EnumeratedLookupBincoder


import os



class InstanceReferencesHandler(object):
	"""Unlike the generic ELB, this will avoid writing the type id and instead assume all
	objects read are for the specific class this is associated with.
	(Which is resolved on read - write already knows the type, since it's merely the type(entry))
	"""

	def __init__(self, filepath, enumerated_lookup=None):
		super(InstanceReferencesHandler, self).__init__(filepath, enumerated_lookup)
		self.representing_class = None

	def read_entries(self):
		# instance lookups are cast to what they represent
		assert self.lookup.label.endswith(' Instances')
		class_path = self.lookup.label[:-len(' Instances')]
		
		# ... and ensure we decode based on the class, since we know the type getting read in
		self.representing_class = resolve_import_path(class_path)
		
		super(InstanceReferencesHandler, self).read_entries()
	
	
	def read_entry(self):
		assert self.representing_class, "InstanceReferencesBincoder should be tuned to the specific class they represent."
		return self.read_object_given_type(self.representing_class)



class InstanceReferencesBincoder(
		InstanceReferencesHandler,
		EnumeratedLookupBincoder,
	):
	pass



class MetaInstancePersistenceMixin(MetaBasePersistenceMixin):

	_INSTANCE_BINCODER_TYPE = InstanceReferencesBincoder

	def __new__(metacls, class_name, class_bases, class_configuration):
		class_configuration['_instance_bincoder'] = None
		class_configuration['__instance_lookup__'] = None
		return super(MetaInstancePersistenceMixin, metacls).__new__(metacls, class_name, class_bases, class_configuration)

	def __init__(cls, class_name, class_bases, class_configuration):
		super(MetaInstancePersistenceMixin, cls).__init__(class_name, class_bases, class_configuration)


	def init_cache(cls, seed=None):
		super(MetaInstancePersistenceMixin, cls).init_cache(seed)
		# ensure instance lookup is initialized uniquely for each subclass
		if cls.__instance_lookup__ is None:
			# use the existing lookup, if any already exists
			cls.__instance_lookup__ = EnumeratedLookup(label=(cls.__classpath__ + ' Instances'))
		# ... but blow the cache anyway to be safe
		cls.__instance_lookup__.clear(cls.__seed__)


	def dump(cls, folder_path, seed=None):
		super(MetaInstancePersistenceMixin, cls).dump(folder_path, seed)
		cls._instance_bincoder.write()

	def load(cls, folder_path, seed=None):
		super(MetaInstancePersistenceMixin, cls).load(folder_path, seed)

		cls._instance_bincoder.read()

		# replace with new lookup generated by bincoder
		cls.__instance_lookup__ = cls._instance_bincoder.lookup
		
		# ... and clear out to ensure it's a one-shot
		cls._instance_bincoder = None


	def _init_bincoders(cls, folder_path, seed=None):
		super(MetaInstancePersistenceMixin, cls)._init_bincoders(folder_path, seed)
		seed = seed or cls.__instance_lookup__.seed
		instance_filepath = cls._instance_bincoder_filepath(folder_path, seed, prep_directory=True)
		cls._instance_bincoder = cls._INSTANCE_BINCODER_TYPE(instance_filepath, cls.__instance_lookup__)


	def _instance_bincoder_filepath(cls, folder_path, seed, prep_directory=False):
		target_folder = cls._target_folder(folder_path, seed, prep_directory)
		return os.path.join(target_folder, 'instances.bin')


	def _verify_bincoder_targets(cls, folder_path, seed=None):
		super(MetaInstancePersistenceMixin, cls)._verify_bincoder_targets(folder_path, seed)
		assert cls._instance_bincoder, 'Instance bincoder not initialized'
		seed = seed or cls.__instance_lookup__.seed
		instance_filepath = cls._instance_bincoder_filepath(folder_path, seed)
		assert os.path.exists(instance_filepath), 'Instance reference lookup file does not exist:  %r' % (instance_filepath,)
		assert instance_filepath == cls._instance_bincoder.filepath, 'Already initialized instance bincoder targetting different filepath'


	def __getitem__(cls, index):
		return cls.__instance_lookup__.value(index)

	def __setitem__(cls, index, instance):
		raise ValueError('Can not set instance sequence - load in order to maintain references')


## NOTE: Do not include __dump__ and __load__ at the instance level - this is a classmethod thing!
#	def __dump__(cls):
#		raise NotImplementedError
#
#	def __load__(cls, instance_ix):
#		raise NotImplementedError



class PersistableInstanceLookupMixin(object):
	"""Include this mixin when making a class that has __instance_lookup__.
	If additional metaclass mangling happens, so long as MetaInstancePersistenceMixin
	is included, it'll work
	"""
	
	__metaclass__ = MetaInstancePersistenceMixin

	def __new__(cls, *args, **kwargs):
		instance = super(PersistableInstanceLookupMixin, cls).__new__(cls, *args, **kwargs)
		_ = cls.__instance_lookup__.index(instance)
		return instance

	# binary encoding stuff
	def __index__(self):
		"""When trying to make sense of a thing, some auto-coerce."""
		return self.__instance_lookup__.index(self)






def _run_tests(dump_location = r'C:\Workspace\temp\coredump'):
	
	from shared.tools.pretty import p,pdir,prettify,install;install()
	from shared.data.types.deduplicated.persistence.instance import PersistableInstanceLookupMixin
	
	import string

	print '=' * 80
	print 'Testing persistence via __dump__ and __load__'

	class PersistanceTest1(PersistableInstanceLookupMixin):
		
		def __init__(self, *args, **kwargs):
			values = dict(
				(attr, value)
				for attr, value 
				in zip(string.ascii_lowercase, args)
			)
			values.update(kwargs)
			
			self._apply_dict(values)
	
		def __dump__(self):
			return self.__dict__
		
		@classmethod
		def __load__(cls, state_dict):
			print state_dict
			instance = cls()
			instance._apply_dict(state_dict)
			return instance
			
		def _apply_dict(self, state_dict):
			for attr, value in state_dict.items():
				setattr(self, attr, value)
		
		def __repr__(self):
			attr_str = ' '.join(
				'%s:%r' % (key, value)
				for key, value
				in sorted(self.__dict__.items()) 	 
				)
			return '<PT1 %s>' % (attr_str,)
	
	
	
	p1 = PersistanceTest1(1,2,3,4, f = 123)
	
	current_seed = PersistanceTest1.__instance_lookup__.seed
	
	PersistanceTest1.dump(dump_location)
	
	p2 = PersistanceTest1(10,20,30, h = 999, j=321)
	
	PersistanceTest1.dump(dump_location)
	
	print '=== instances (after dump) ==='
	p(PersistanceTest1.__instance_lookup__.__lookup_table__)
	
	PersistanceTest1.init_cache(123456)
	
	PersistanceTest1.load(dump_location, current_seed)
	
	print '=== instances (after load) ==='
	p(PersistanceTest1.__instance_lookup__.__lookup_table__)
	
	
	assert PersistanceTest1[0].c == 3
	assert PersistanceTest1[1].__dict__ == {'a':10, 'b':20, 'c':30, 'h':999, 'j':321}
	assert PersistanceTest1[0] is not None


	print '=' * 80
	print 'Testing persistence via __getnewargs_ex__'
	
	class PersistanceTest2(PersistableInstanceLookupMixin):
		
		def __init__(self, *args, **kwargs):
			values = dict(
				(attr, value)
				for attr, value 
				in zip(string.ascii_lowercase, args)
			)
			values.update(kwargs)
			
			self._apply_dict(values)
	
	
		def __getnewargs_ex__(self):
			args = []
			for arg in string.ascii_lowercase:
				if arg in self.__dict__:
					args.append(self.__dict__[arg])
				else:
					break
			kwargs = {}
			for kwarg, value in self.__dict__.items():
				if kwarg>arg:
					kwargs[kwarg] = value
		
			init_details = (args, kwargs,)
			return init_details
		
		def _apply_dict(self, state_dict):
			for attr, value in state_dict.items():
				setattr(self, attr, value)
		
		def __repr__(self):
			attr_str = ' '.join(
				'%s:%r' % (key, value)
				for key, value
				in sorted(self.__dict__.items()) 	 
				)
			return '<PT2 %s>' % (attr_str,)
	
	
	
	p1 = PersistanceTest2(1,2,3,4, f = 123)
	
	current_seed = PersistanceTest2.__instance_lookup__.seed
	
	PersistanceTest2.dump(dump_location)
	
	p2 = PersistanceTest2(10,20,30, h = 999, j=321)
	
	PersistanceTest2.dump(dump_location)
	
	print '=== instances (after dump) ==='
	p(PersistanceTest2.__instance_lookup__.__lookup_table__)
	
	PersistanceTest2.init_cache(123456)
	
	PersistanceTest2.load(dump_location, current_seed)
	
	print '=== instances (after load) ==='
	p(PersistanceTest2.__instance_lookup__.__lookup_table__)
	
	
	assert PersistanceTest2[0] is not None
	assert PersistanceTest2[0].c == 3
	assert PersistanceTest2[1].__dict__ == {'a':10, 'b':20, 'c':30, 'h':999, 'j':321}
	




















